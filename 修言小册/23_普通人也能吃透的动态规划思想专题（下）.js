// 0-1背包

// 对于0-1背包，整体来说需要弄明白两个地方
// 1.思路
// 2.代码
// 当然上面分的很广，似乎每道算法题都应该这么理解。。。

// 思路：
// 其实这里我说的思路就是关于状态转移方程的理解。
// 我们采取倒推的方式去理解0-1背包状态转移方程的产生。
// 先设好这一堆变量，假设现在i，v就是这道题要求的，即一共i件物品，背包容量是v，求最大价值
// dp[i][v]表示i-1之前的物品已经尝试完了，现在要判断是否加入第i件，并且不能超过背包容量，所能达到最大值
// 假设这个背包已经装好了，现在就是在第i件物品的位置，当然，有可能第i件并不存在于背包，但是我们现在是在处理第i件物品之后，是否加入背包先不考虑
// 然后我们现在拿到最终背包，要开始拿出一件物品，需要求拿出一件物品之后的价值，
// 拿出一件物品当然说的就是i，那么它有两种情况，一种就是第i件物品在，我们拿出，另一种是第i件物品不在，我们不需要拿出，
// 如果第i件不在，那么很简单，此时dp[i][v] = dp[i-1][v],为什么i回溯到i-1，但是v不变呢，因为这个i没装进去，所以就要看i-1的时候，背包总量要尽量装满吧，总之背包容量大一定比容量小能装的物品的价格更高，所以索性直接就看在第i-1件物品的时候，吧容量拉到最满，去看它的最大价值
// 如果第i件已经在了，此时dp[i][v] = dp[i-1][v-w[i]] + value[i]，如果第i件放进来了，那么上一个状态价值就是dp[i-1][v-w[i]]，不光物品要往前回溯，背包所用容量也得回溯，得留出能放入i的容量
// 两种情况下，我们每次取最大值，dp[i][v] = max(dp[i-1][v-w[i]] + value[i],dp[i-1][v])
// 但是我们刚才是从后往前想的，但是dp要从头开始遍历填表，那应该怎么做呢，
// 就是第i件物品怎样处理，依赖于第i-1个物品，那也就是说，我们先处理好第1件物品的状态不就可以了，第一行数据很好处理，因为这时候物品只有一个，能放就放，不能放价值就是0
// 第一行填好，后面二维数组就顺着遍历就完了

// 接下来说代码：
// 代码主要就是两个点，一是取初识化一个怎样的数组，首先几行，至少有n行，n件物品，但是因为第一行去填充数据的时候也需要更前面一行数据来支撑，纯粹是为了代码好写，就在顶上多加一行0，所以n+1行。 那么有几列呢？至少c列，从容量为1到c，但是由于代码是从零开始，为了逻辑比较好像，就多申请一列，第0列就不用了，放着就好
// 第二个点，因为状态转移公式里面，用到了w和value数组，但是这俩数组是从0开始的，但是我们遍历为了方便从一，所以方程里面用到的时候要写i-1

// 入参是物品的个数和背包的容量上限，以及物品的重量和价值数组
function knapsack(n, c, w, value) {
  // dp是动态规划的状态保存数组
  const dp = new Array(n + 1);
  for (let i = 0; i < dp.length; i++) {
    dp[i] = new Array(c + 1).fill(0);
  }

  // res 用来记录所有组合方案中的最大值
  for (let i = 1; i <= n; i++) {
    for (let v = 1; v <= c; v++) {
      if (v - w[i - 1] < 0) {
        dp[i][v] = dp[i - 1][v];
      } else
        dp[i][v] = Math.max(
          dp[i - 1][v],
          dp[i - 1][v - w[i - 1]] + value[i - 1]
        );
    }
  }
  console.log(dp);

  return dp[(n, c)];
}

const ret = knapsack(3, 4, [2, 1, 3], [4, 2, 3]);
console.log(ret);
// 对于0-1背包，目前就先整明白二维数组的解法，滑动一维数组先算了。。


// 最长递增子序列
// 不知为何有人说这题比背包难，这简直比背包简单多了
// 一行就能解释完，就是给序列中每个节点写一个状态，dp数组就存储这个状态，没遍历到一个元素（索引为i），回头看，如果遇到前面元素小于当前元素（索引为j），那就dp[i] = max(dp[i],dp[j] + 1)，就完了。。
/**
 * @param {number[]} nums
 * @return {number}
 */
 var lengthOfLIS = function (nums) {
    const len = nums.length

    let res = 1
    const dp = new Array(nums.length).fill(1)
    for (let i = 1; i < len; i++) {
        for (let j = 0; j < i; j++)
            if (nums[j] < nums[i]) dp[i] = Math.max(dp[i], dp[j] + 1)
        res = dp[i] > res ? dp[i] : res
    }

    return res
};